/*
Parker Conroy
ARLab

Visual Servoing of ARdrone from Point feature.


*/
//#include <stdio.h>
#include <ros/ros.h>
//#include <ros/time.h>
//#include <sensor_msgs/RegionOfInterest.h>
//#include <sensor_msgs/CameraInfo.h>
//#include <sensor_msgs/Joy.h>
#include <geometry_msgs/Twist.h>
#include <geometry_msgs/Point.h>

//Coordinate definitions for vectors
const int x =0;
const int y =1;
const int z =2;

//parameters
const float error_scale=.005;
const float error_scale_z=.001;
const int des_z= 15;
int had_message =0;

//gloabs
float kp[3];
float kd[3];
float ki[3];
float trackee_position[3];
float temp_trackee_position[3];
float error[3];
float dt_error[3];
float error_old[3];
float integral_error[3];
float control[3];
double msg_time;
double dt;



    
	
	geometry_msgs::Twist twist_msg;
	geometry_msgs::Point point_msg;
	
	void point_callback(const geometry_msgs::Point& point_in)
{
had_message=1;
//Take in point
temp_trackee_position[x]=point_in.y;
temp_trackee_position[y]=point_in.x;
temp_trackee_position[z]=point_in.z;

}


int main(int argc, char** argv)
{
	ros::init(argc, argv,"ARDrone_point_controller");
    ros::NodeHandle n;
    ros::Rate loop_rate(100);
	
	msg_time =0.0;
	dt= 0.0;

	error[x]=0.0;
	error[y]=0.0;
	error[z]=0.0;
	dt_error[x]=0.0;
	dt_error[y]=0.0;
	dt_error[z]=0.0;
	integral_error[x]=0.0;
	integral_error[y]=0.0;
	integral_error[z]=0.0;
	//PID GAINS
	kp[x]=1;
	kp[y]=1;
	kp[z]=1;

	kd[x]=0;
	kd[y]=0;
	kd[z]=0;

	ki[x]=0;
	ki[y]=0;
	ki[z]=0;

	ros::Publisher pub;
	ros::Subscriber point_sub;
	ros::Subscriber cam_sub;

	//cam_sub = n.subscribe("/ardrone/camera_info", 1, cam_callback);

    pub = n.advertise<geometry_msgs::Twist>("/cmd_vel", 1); //que of 1 
	point_sub = n.subscribe("ardrone_tracker/found_point", 10, point_callback);

 	while (ros::ok()) 
			{

			if (had_message)
				{			
				dt= msg_time-(double)ros::Time::now().toSec(); //record time for dt error

				//read variable incase it changes during error calculation
				trackee_position[x]=temp_trackee_position[x];
				trackee_position[y]=temp_trackee_position[y];
				trackee_position[z]=temp_trackee_position[z];

				//Calculate x-y error from difference in point vs center of camera image
				error[x]=error_scale*(trackee_position[x]-50);
				error[y]=error_scale*(trackee_position[y]-50);
				//Calculate z error from desired point size 
				error[z]=error_scale_z*(des_z-trackee_position[z]);

				//printf("point x:%f y:%f z:%f \n",trackee_position[x], trackee_position[y],trackee_position[z]);
				//printf("cam x:%d y:%d \n", cam_x, cam_y);


				dt_error[x]=(-error[x]+error_old[x])/dt;
				dt_error[y]=(-error[y]+error_old[y])/dt;
				dt_error[z]=(-error[z]+error_old[z])/dt;

				integral_error[x]=integral_error[x]+error[x]; //set integral
				integral_error[y]=integral_error[y]+error[y];
				integral_error[z]=integral_error[z]+error[z];

				//printf("error_dot x:%f y:%f \n", dt_error[x], dt_error[y]);
				//printf("int_error x:%f y:%f \n", integral_error[x], integral_error[y]);

//printf("error x:%f y:%f z:%f \n", error[x], error[y], error[z]);

				control[x]= kp[x]*error[x]+kd[x]*dt_error[x]+ki[x]*integral_error[x]; //set controls w/ PID
				control[y]= kp[y]*error[y]+kd[y]*dt_error[y]+ki[y]*integral_error[y];
				control[z]= kp[z]*error[z]+kd[z]*dt_error[z]+ki[z]*integral_error[z];
				
//printf("control x:%f y:%f z:%f \n", control[x], control[y], control[z]);				
	
				//Create command message
				twist_msg.linear.x=-control[x]; //controls are oposite
				twist_msg.linear.y=-control[y];	//controls are oposite
				twist_msg.linear.z=-control[z];

//printf("twist x:%f y:%f z:%f \n", twist_msg.linear.x, twist_msg.linear.y, twist_msg.linear.z);	

				//set terms for next cycle, error and time
				error_old[x]=error[x];
				error_old[y]=error[y];
				error_old[z]=error[z];
				msg_time = (double)ros::Time::now().toSec();
				

				//Clean outputs
				if(twist_msg.linear.x >1) {
						twist_msg.linear.x =1;}
				else if(twist_msg.linear.x <-1) {
						twist_msg.linear.x =-1;}
			
				if(twist_msg.linear.y >1) {
						twist_msg.linear.y =1;}
				else if(twist_msg.linear.y <-1) {
					twist_msg.linear.y =-1;}

				if(twist_msg.linear.z >1) {
						twist_msg.linear.z =1;}
				else if(twist_msg.linear.z <-1) {
					twist_msg.linear.z =-1;}
	

				pub.publish(twist_msg);
				}//if had message
			ros::spinOnce();
														
			}//ros::ok

}//main
